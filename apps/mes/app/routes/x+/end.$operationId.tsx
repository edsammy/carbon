import { error, getCarbonServiceRole, success } from "@carbon/auth";
import { requirePermissions } from "@carbon/auth/auth.server";
import { flash } from "@carbon/auth/session.server";
import { FunctionRegion } from "@supabase/supabase-js";
import { redirect, type LoaderFunctionArgs } from "@vercel/remix";
import {
  endProductionEventsForJobOperation,
  finishJobOperation,
  getTrackedEntitiesByMakeMethodId,
  insertProductionQuantity,
} from "~/services/operations.service";
import { path } from "~/utils/path";

export async function loader({ request, params }: LoaderFunctionArgs) {
  const { userId, companyId } = await requirePermissions(request, {});

  const { operationId } = params;
  if (!operationId) throw new Error("Operation ID is required");

  const url = new URL(request.url);
  let trackedEntityId = url.searchParams.get("trackedEntityId");

  const serviceRole = await getCarbonServiceRole();

  const [jobOperation, productionQuantities] = await Promise.all([
    serviceRole
      .from("jobOperation")
      .select("*")
      .eq("id", operationId)
      .maybeSingle(),
    serviceRole
      .from("productionQuantity")
      .select("*")
      .eq("jobOperationId", operationId),
  ]);

  if (
    jobOperation.error ||
    !jobOperation.data ||
    !jobOperation.data.jobMakeMethodId
  ) {
    throw redirect(
      path.to.operations,
      await flash(
        request,
        error(jobOperation.error, "Failed to fetch job operation")
      )
    );
  }

  if (jobOperation.data?.companyId !== companyId) {
    throw redirect(
      path.to.operations,
      await flash(
        request,
        error("You are not authorized to start this operation", "Unauthorized")
      )
    );
  }

  const endEvents = await endProductionEventsForJobOperation(serviceRole, {
    jobOperationId: jobOperation.data.id,
    employeeId: userId,
    companyId,
  });

  if (endEvents.error) {
    throw redirect(
      path.to.operations,
      await flash(request, error(endEvents.error, "Failed to end event"))
    );
  }

  const [jobMakeMethod] = await Promise.all([
    serviceRole
      .from("jobMakeMethod")
      .select("*")
      .eq("id", jobOperation.data.jobMakeMethodId)
      .maybeSingle(),
  ]);

  if (jobMakeMethod.error || !jobMakeMethod.data) {
    throw redirect(
      path.to.operations,
      await flash(
        request,
        error(jobMakeMethod.error, "Failed to fetch job make method")
      )
    );
  }

  const currentQuantity =
    productionQuantities.data?.reduce((acc, curr) => acc + curr.quantity, 0) ??
    0;

  const quantityToComplete =
    (jobOperation.data.operationQuantity ?? 0) - currentQuantity;

  const isTrackedEntity =
    jobMakeMethod.data.requiresSerialTracking ||
    jobMakeMethod.data.requiresBatchTracking;

  if (quantityToComplete > 0) {
    if (isTrackedEntity) {
      if (!trackedEntityId) {
        const trackedEntities = await getTrackedEntitiesByMakeMethodId(
          serviceRole,
          jobOperation.data.jobMakeMethodId
        );

        if (trackedEntities.data && trackedEntities.data.length > 0) {
          trackedEntityId =
            trackedEntities.data[trackedEntities.data.length - 1].id;
        }
      }

      if (jobMakeMethod.data.requiresSerialTracking) {
        const response = await serviceRole.functions.invoke("issue", {
          body: {
            type: "jobOperationSerialComplete",
            quantity: 1,
            jobOperationId: jobOperation.data.id,
            trackedEntityId,
            trackingType: "Serial",
            notes: "Generated by QR code",
            companyId,
            userId,
          },
          region: FunctionRegion.UsEast1,
        });

        const newTrackedEntityId = response.data?.newTrackedEntityId;

        if (newTrackedEntityId) {
          throw redirect(
            `${path.to.operation(
              operationId
            )}?trackedEntityId=${newTrackedEntityId}`
          );
        }
      } else if (jobMakeMethod.data.requiresBatchTracking) {
        const response = await serviceRole.functions.invoke("issue", {
          body: {
            type: "jobOperationBatchComplete",
            quantity: quantityToComplete,
            jobOperationId: jobOperation.data.id,
            trackedEntityId,
            trackingType: "Batch",
            notes: "Generated by QR code",
            companyId,
            userId,
          },
          region: FunctionRegion.UsEast1,
        });

        if (response.error) {
          throw redirect(
            path.to.operation(operationId),
            await flash(
              request,
              error(response.error, "Failed to complete job operation")
            )
          );
        }
      }
    } else {
      const insertProduction = await insertProductionQuantity(serviceRole, {
        quantity: quantityToComplete,
        jobOperationId: jobOperation.data.id,
        notes: "Generated by QR code",
        companyId,
        createdBy: userId,
      });

      if (insertProduction.error) {
        throw redirect(
          path.to.operation(operationId),
          await flash(
            request,
            error(
              insertProduction.error,
              "Failed to record production quantity"
            )
          )
        );
      }

      const issue = await serviceRole.functions.invoke("issue", {
        body: {
          id: operationId,
          type: "jobOperation",
          quantity: quantityToComplete,
          companyId,
          userId,
        },
        region: FunctionRegion.UsEast1,
      });

      if (issue.error) {
        throw redirect(
          path.to.operation(operationId),
          await flash(request, error(issue.error, "Failed to issue materials"))
        );
      }
    }
  }

  const finishOperation = await finishJobOperation(serviceRole, {
    jobOperationId: jobOperation.data.id,
    userId,
  });

  if (finishOperation.error) {
    throw redirect(
      path.to.operation(operationId),
      await flash(
        request,
        error(finishOperation.error, "Failed to finish operation")
      )
    );
  }

  throw redirect(
    path.to.operations,
    await flash(request, success("Operation finished successfully"))
  );
}
